Добрый день. Спасибо за задание. Рассказываю шаги запуска приложения (много раз протестировал
его в соответствии с требованиями, но если вдруг что-то не так, то буду благодарен за фидбек).

----------------------------------------------------------------------------------------------------------------------------

Все эндпоинты были протестированы при помощи 100 параллельных потоков в Postman Collection Performance.
Также были успешно пройдены все unit-тесты.

Какие запросы принимают эндпоинты (по заданию их 3):

1. Эндпоинт для приема данных синхронизации от пользователя (при отправки json с таким же uuid поле money перезаписывается)
	URL: /api/sync
	Метод: POST

	Тело запроса:
	
	{
		"uuid": "1e6",
		"money": 1000,
		"country": "RU",
		"createdAt": "2023-12-04T21:24:00"
	}

	Пример ответа:

	{
		"message": "Data received"
	}

2. Эндпоинт для отправки данных пользователю (вложенный лист сущностей с ленивой загрузкой, так как обратно нам не надо получать activity)
	URL: /api/sync/{uuid}
	Метод: GET

	Пример ответа:

	{
		"id": 1,
		"uuid": "1e6",
		"money": 1000,
		"country": "RU",
		"createdAt": "2023-12-04T21:24:00"
	}

3. Эндпоинт для приема игровой статистики от пользователя
	URL: /api/stats
	Метод: POST

	Тело запроса:

	{
		"activity": 777,
		"timestamp": "2023-10-10T15:30:00",
		"userSyncData": {
			"uuid": "1e6"
		}
	}

	Пример ответа:

	{
		"message": "Activity recorded"
	}

----------------------------------------------------------------------------------------------------------------------------

В качестве хранилища было выбрано PostgreSQL.
Вид таблиц в БД:

create table user_sync_data
(
    id         int generated by default as identity primary key,
    uuid       varchar NOT NULL UNIQUE,
    money      int CHECK (money >= 0),
    country    varchar,
    created_at timestamp NOT NULL
);

create table user_activity_data
(
    id        int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sync_uuid varchar REFERENCES user_sync_data (uuid),
    activity  int CHECK (activity >= 0),
    timestamp timestamp DEFAULT CURRENT_TIMESTAMP
);

----------------------------------------------------------------------------------------------------------------------------

В задании было указано прикрепить архив (отправил вместе с письмом).

Также в качестве доп. условия был написан Docker-compose.yml файл, который можно развернуть
из директории "/CarX-Technical-Task" при помощи команды `docker-compose up`. Сборка в jar файл 
осуществляется автоматизированно. Единственное, что необходимо самостоятельно сделать -
дамп базы данных при помощи команды `pg_dump -U postgres GameData_db > GameData_db-dump.sql` и
поместить файл в директорию "/database/dump".
Для удобства был опубликован внешний порт "8080", чтобы вы могли совершать запросы к эндпоинтам напрямую
с хоста по адресу "localhost:8080/api", а не изнутри контейнера.

----------------------------------------------------------------------------------------------------------------------------

Запросы к БД для отдела аналитики:
1) быстро выбирать Х пользователей с самым большим текущим значением "money" по каждой стране "country". 
2) иметь возможность быстро подсчитать количество новых пользователей по каждой стране за период Х. 
3) для каждого конкретного пользователя X быстро получить отсортированный по дате список значений показателя "activity" и даты их получения за период Y.

1)SELECT *
FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY country ORDER BY money DESC) AS rank
      FROM user_sync_data) AS ranked
WHERE rank <= 10;
2) SELECT country, COUNT(*) AS new_users
FROM user_sync_data
WHERE created_at BETWEEN '2023-12-03 21:24:00.000000' AND '2023-12-05 21:24:00.000000'
GROUP BY country;
3)SELECT activity, timestamp
FROM user_activity_data
WHERE sync_uuid = '1e15' AND timestamp BETWEEN '2023-10-9 15:30:00.000000' AND '2023-10-11 15:30:00.000000'
ORDER BY timestamp;

----------------------------------------------------------------------------------------------------------------------------

В перспективе вижу применение к этому проекту аутентификации при помощи Spring Security, используя JWT,
чтобы при обращении на указанные эндпоинты данные мог переписать только их владелец.
